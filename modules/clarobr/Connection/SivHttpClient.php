<?php

namespace ClaroBR\Connection;

use ClaroBR\Enumerators\ClaroBRCaches;
use ClaroBR\Exceptions\SivInvalidCredentialsException;
use ClaroBR\Exceptions\SivUnavailableException;
use ClaroBR\SivHeaders;
use GuzzleHttp\Client;
use GuzzleHttp\Exception\ClientException;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Exception\ServerException;
use GuzzleHttp\Psr7\Response;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;
use TradeAppOne\Domain\Enumerators\Operations;
use TradeAppOne\Domain\HttpClients\Responseable;
use TradeAppOne\Domain\HttpClients\Restful\RestFulClient;

class SivHttpClient extends RestFulClient
{
    public function __construct(Client $client)
    {
        $this->client = $client;
    }

    public function authenticate(string $cpf): void
    {
        $bearer = Cache::get(ClaroBRCaches::USER_BEARER . $cpf);
        if (! $bearer) {
            $response = $this->post(SivRoutes::AUTH, [
                'cpf'      => $cpf,
                'password' => app()->make(SivHeaders::class)->getToken()
            ]);

            $responseArray = $response->toArray();
            $bearer        = data_get($responseArray, 'data.token');

            if ($response->getStatus() !== \Illuminate\Http\Response::HTTP_OK || blank($bearer)) {
                $message = data_get($responseArray, 'data.message');
                throw new SivInvalidCredentialsException($message);
            }

            Cache::put(ClaroBRCaches::USER_BEARER . $cpf, $bearer, ClaroBRCaches::AUTHENTICATION_DUE);
        }
        $this->pushHeader(['Authorization' => 'Bearer ' . $bearer]);
    }

    public function execute($method, $url, $options): Response
    {
        $start = microtime(true);
        try {
            $response = $this->client->request($method, $url, $options);
            heimdallLog()->realm(Operations::CLARO)
                ->start($start)
                ->end(microtime(true))
                ->request($options)
                ->response($response)
                ->url($url)
                ->httpClient($this->client)
                ->fire();
            return $response;
        } catch (ConnectException | ServerException | RequestException | ClientException $exception) {
            if ($exception instanceof ConnectException) {
                heimdallLog()->realm(Operations::CLARO)
                  ->start($start)
                  ->end(microtime(true))
                  ->request($options)
                  ->catchException($exception)
                  ->url($url)
                  ->httpClient($this->client)
                  ->fire();
                throw new SivUnavailableException($exception->getMessage());
            } else {
                $response = $exception->getResponse();
                if ($response) {
                    heimdallLog()->realm(Operations::CLARO)
                        ->start($start)
                        ->end(microtime(true))
                        ->request($options)
                        ->response($response)
                        ->url($url)
                        ->httpClient($this->client)
                        ->fire();
                    return $response;
                }
                heimdallLog()->realm(Operations::CLARO)
                  ->start($start)
                  ->end(microtime(true))
                  ->request($options)
                  ->catchException($exception)
                  ->url($url)
                  ->httpClient($this->client)
                  ->fire();
                throw new SivUnavailableException($exception->getMessage());
            }
        }
    }

    public function get(string $url, array $query = [], array $headers = []): Responseable
    {
        $this->selectApiKeyByUserContext();
        return parent::get($url, $query, $headers); // TODO: Change the autogenerated stub
    }

    public function put(string $url = '', array $body = [], array $header = []): Responseable
    {
        $this->selectApiKeyByUserContext();
        return parent::put($url, $body, $header); // TODO: Change the autogenerated stub
    }

    public function delete(string $url = '', array $body = [], array $header = []): Responseable
    {
        $this->selectApiKeyByUserContext();
        return parent::delete($url, $body, $header); // TODO: Change the autogenerated stub
    }

    public function post(string $url = '', array $body = [], array $headers = []): Responseable
    {
        $this->selectApiKeyByUserContext();
        return parent::post($url, $body, $headers); // TODO: Change the autogenerated stub
    }

    public function postFormParams(string $url = '', array $form = [], array $headers = []): Responseable
    {
        $this->selectApiKeyByUserContext();
        return parent::postFormParams($url, $form, $headers); // TODO: Change the autogenerated stub
    }

    private function selectApiKeyByUserContext(): void
    {
        $user         = Auth::user();
        $sivHeaders   = resolve(SivHeaders::class);
        $customApiKey = $sivHeaders->getCustomHeaders();

        if ($user && $user->isInovaPromoter()) {
            $this->pushHeader([
                'x-api-key' => data_get($customApiKey, 'x-api-key-alternative')
            ]);
        } else {
            $this->pushHeader([
                'x-api-key' => data_get($customApiKey, 'x-api-key')
            ]);
        }
    }
}
